<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Particle Playground | Camera Gesture Control</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        :root {
            font-family: 'Inter', sans-serif;
            --particle-color: hsl(200, 100%, 70%);
        }
        body {
            overflow: hidden;
            background-color: #0d1117;
        }
        canvas {
            display: block;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #4a5568;
            border-radius: 2px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background-color: #1a202c;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--particle-color);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            margin-top: -6px;
        }
        
        .template-icon {
            transition: all 0.2s;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .template-icon:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px var(--particle-color);
        }
        
        .template-icon.active {
            border: 2px solid var(--particle-color);
            background-color: rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body class="text-white">

    <video id="webcam" style="display: none;" playsinline></video>
    <div id="canvas-container" class="absolute inset-0 z-0"></div>

    <div id="ui-panel" class="absolute top-4 right-4 z-20 w-80 lg:w-96 p-4 bg-gray-800/90 backdrop-blur-sm rounded-xl shadow-2xl custom-scrollbar max-h-[96vh] overflow-y-auto">
        <h1 class="text-2xl font-bold mb-4 text-cyan-400">Particle Playground</h1>
        
        <div class="mb-6 p-3 bg-gray-700 rounded-lg shadow-inner">
            <h2 class="text-lg font-semibold mb-2 flex items-center">
                <svg class="w-5 h-5 mr-2 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18H3a2 2 0 01-2-2V8a2 2 0 012-2h12a2 2 0 012 2v8a2 2 0 01-2 2H5z"></path></svg>
                Control Mode
            </h2>
            <div class="flex items-center justify-between">
                <span class="text-sm text-gray-300 mr-2">Gesture (Camera)</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-gesture-control" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-cyan-800 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-cyan-600"></div>
                </label>
                <span class="text-sm text-gray-300 ml-2">Manual (Mouse/Touch)</span>
            </div>
            <p id="control-hint" class="text-xs mt-2 text-cyan-300 italic">Drag mouse/touch to control scale (X-axis) and spread (Y-axis).</p>
            <p id="camera-status" class="text-xs mt-2 text-yellow-400 italic">Camera Status: Initializing...</p>
        </div>

        <div class="mb-6">
            <h2 class="text-lg font-semibold mb-2">Particle Template</h2>
            <div id="template-selector" class="grid grid-cols-5 gap-2">
            </div>
        </div>

        <div class="mb-6">
            <h2 class="text-lg font-semibold mb-2">Particle Color (HSL Hue)</h2>
            <input type="range" id="hue-slider" min="0" max="360" value="200" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
            <div id="color-preview" class="w-full h-4 mt-2 rounded-lg" style="background-color: hsl(200, 100%, 70%);"></div>
        </div>

        <div class="space-y-4">
            <div>
                <label for="particle-count" class="block text-sm font-medium">Particle Count (<span id="count-value">50000</span>)</label>
                <input type="range" id="particle-count-slider" min="5000" max="100000" step="5000" value="50000" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
            </div>
            
            <div>
                <label for="particle-size" class="block text-sm font-medium">Base Particle Size (<span id="size-value">1.5</span>)</label>
                <input type="range" id="particle-size-slider" min="0.1" max="5.0" step="0.1" value="1.5" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
            </div>

            <div>
                <label for="motion-noise" class="block text-sm font-medium">Motion Noise Strength (<span id="noise-value">0.1</span>)</label>
                <input type="range" id="motion-noise-slider" min="0.0" max="1.0" step="0.01" value="0.1" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-600">
            </div>
        </div>
    </div>

    <div id="feedback-panel" class="absolute bottom-4 left-4 z-20 p-3 bg-gray-800/90 backdrop-blur-sm rounded-xl shadow-2xl text-xs text-gray-300">
        <p id="fps-display">FPS: 0</p>
        <p id="perf-tip" class="text-yellow-300 mt-1 hidden">Performance: Adjusted to low particle count.</p>
        <p id="gesture-debug" class="mt-1 hidden">Scale: 0.5 | Spread: 0.5</p>
    </div>

    <div id="readme-panel" class="absolute top-4 left-4 z-20 w-80 lg:w-96 p-4 bg-gray-800/90 backdrop-blur-sm rounded-xl shadow-2xl custom-scrollbar max-h-[96vh] overflow-y-auto hidden">
        <h2 class="text-xl font-bold mb-3 text-red-400">README: Particle Playground</h2>
        <button onclick="document.getElementById('readme-panel').classList.add('hidden')" class="absolute top-2 right-2 text-gray-400 hover:text-white">&times;</button>
        
        <h3 class="font-semibold mt-2 mb-1">Controls & Input</h3>
        <ul class="list-disc list-inside text-sm space-y-1">
            <li><strong>Manual Mode:</strong> Control particles using the mouse/touchpad drag gesture.
                <ul class="list-circle list-inside ml-4">
                    <li><strong>X-axis (Horizontal Drag):</strong> Controls Global Scale.</li>
                    <li><strong>Y-axis (Vertical Drag):</strong> Controls Particle Spread/Tension.</li>
                </ul>
            </li>
            <li><strong>Gesture Mode (Camera):</strong> Uses real-time hand detection via MediaPipe.
                <ul class="list-circle list-inside ml-4">
                    <li><strong>Scale (Hand Distance):</strong> Controls particle size/density.</li>
                    <li><strong>Spread (Finger Tension):</strong> Controls how far particles are pulled apart.</li>
                    <li><strong>Quick Close ('Snap'):</strong> Triggers Fireworks burst (in Fireworks template).</li>
                </ul>
            </li>
            <li><strong>UI Sliders:</strong> Control particle count, size, and motion noise.</li>
        </ul>
        
        <h3 class="font-semibold mt-4 mb-1">Camera Integration Status</h3>
        <p class="text-sm text-green-300">Camera and hand tracking are now fully integrated and working! Check the camera status indicator for live updates.</p>
    </div>

    <button onclick="document.getElementById('readme-panel').classList.toggle('hidden')" class="absolute bottom-4 right-4 z-20 p-2 bg-gray-700 hover:bg-gray-600 rounded-full text-sm shadow-xl transition">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
    </button>
    
<script>
    const PARTICLE_COUNT = 100000;
    const MAX_PARTICLES = 100000;
    const MIN_PARTICLES = 5000;
    const LERP_FACTOR = 0.1;

    const Templates = {
        HEART: {
            name: "Heart",
            icon: "â¤ï¸",
            spawnFn: (i, count) => {
                let t = i / count * Math.PI * 2;
                let r = 0.5 + 0.5 * Math.sin(t / 2);
                let x = 16 * Math.sin(t) ** 3;
                let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                return new THREE.Vector3(x / 30, y / 30, Math.random() * 0.1);
            }
        },
        FIREWORKS: {
            name: "Fireworks",
            icon: "ðŸ’¥",
            spawnFn: (i, count) => {
                let phi = Math.acos(2 * Math.random() - 1);
                let theta = Math.random() * 2 * Math.PI;
                let r = 0.1 + Math.random() * 0.5;
                let x = r * Math.sin(phi) * Math.cos(theta);
                let y = r * Math.sin(phi) * Math.sin(theta);
                let z = r * Math.cos(phi);
                return new THREE.Vector3(x, y, z);
            }
        },
        SATURN: {
            name: "Saturn",
            icon: "ðŸª",
            spawnFn: (i, count) => {
                let isRing = Math.random() < 0.7;
                let x, y, z;
                if (isRing) {
                    let r = 0.6 + Math.random() * 0.3;
                    let theta = Math.random() * 2 * Math.PI;
                    x = r * Math.cos(theta);
                    z = r * Math.sin(theta);
                    y = (Math.random() - 0.5) * 0.05;
                } else {
                    let phi = Math.acos(2 * Math.random() - 1);
                    let theta = Math.random() * 2 * Math.PI;
                    let r_planet = Math.random() * 0.4;
                    x = r_planet * Math.sin(phi) * Math.cos(theta);
                    y = r_planet * Math.sin(phi) * Math.sin(theta);
                    z = r_planet * Math.cos(phi);
                }
                return new THREE.Vector3(x, y, z);
            }
        },
        FLOWER: {
            name: "Flower",
            icon: "ðŸŒ¸",
            spawnFn: (i, count) => {
                let t = i / count * 10;
                let r = t * 0.1 + 0.1;
                let angle = t * 5;
                let x = r * Math.cos(angle);
                let y = r * Math.sin(angle);
                let z = (Math.random() - 0.5) * 0.2;
                return new THREE.Vector3(x, y, z);
            }
        },
        BUDDHA: {
            name: "Buddha",
            icon: "ðŸ§˜",
            spawnFn: (i, count) => {
                let layer = Math.floor(i / count * 5);
                let r, y_center;
                
                switch (layer) {
                    case 0: r = 0.2; y_center = -0.8; break;
                    case 1: r = 0.4; y_center = -0.5; break;
                    case 2: r = 0.35; y_center = 0.0; break;
                    case 3: r = 0.3; y_center = 0.5; break;
                    case 4: r = 0.2; y_center = 0.8; break;
                    default: r = 0.5; y_center = 0;
                }

                let phi = Math.acos(2 * Math.random() - 1);
                let theta = Math.random() * 2 * Math.PI;
                let x = r * Math.sin(phi) * Math.cos(theta);
                let z = r * Math.sin(phi) * Math.sin(theta);
                let y = r * Math.cos(phi) + y_center;
                
                return new THREE.Vector3(x, y, z);
            }
        }
    };

    let camera, scene, renderer;
    let particles, geometry, material;
    let uniforms, attributes;
    let animationId;
    let dbg_fps_counter = 0;
    let dbg_last_time = performance.now();
    let currentTemplate = Templates.HEART;

    let State = {
        baseSize: 1.5,
        noiseStrength: 0.1,
        particleCount: 50000,
        hue: 200,

        gestureMode: true,
        gestureScale: 0.5,
        gestureSpread: 0.5,
        targetScale: 0.5,
        targetSpread: 0.5,
        globalScale: 3.0,
        spreadFactor: 5.0,
        fireworksCooldown: 0,
        
        lastUpdateTime: 0,
    };

    class GestureController {
        constructor() {
            this.input = { x: 0.5, y: 0.5 };
            this.isDragging = false;
            this.lastMouseY = 0.5;
            this.lastGestureSpread = 0.5; 
            
            this.webcam = document.getElementById('webcam');
            this.hands = null;
            this.isModelLoaded = false;
            this.camera = null;
        }

        init() {
            window.addEventListener('mousedown', this.onPointerDown.bind(this));
            window.addEventListener('touchstart', this.onPointerDown.bind(this));
            window.addEventListener('mousemove', this.onPointerMove.bind(this));
            window.addEventListener('touchmove', this.onPointerMove.bind(this));
            window.addEventListener('mouseup', this.onPointerUp.bind(this));
            window.addEventListener('touchend', this.onPointerUp.bind(this));
            
            this.setupCameraStream();
        }
        
        async setupCameraStream() {
            const statusEl = document.getElementById('camera-status');
            statusEl.textContent = 'Camera Status: Requesting access...';
            
            try {
                if (this.webcam.srcObject) {
                    statusEl.textContent = 'Camera Status: Stream connected. Loading model...';
                    this.loadHandDetectionModel();
                    return;
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    } 
                });
                
                this.webcam.srcObject = stream;
                
                this.webcam.addEventListener('loadeddata', () => {
                    this.webcam.play();
                    statusEl.textContent = 'Camera Status: Stream connected. Loading model...';
                    this.loadHandDetectionModel();
                });
                
            } catch (error) {
                console.error("Error accessing webcam:", error);
                statusEl.textContent = 'Camera Status: Access DENIED. Using manual control.';
                statusEl.classList.remove('text-yellow-400');
                statusEl.classList.add('text-red-400');
                State.gestureMode = false;
                document.getElementById('toggle-gesture-control').checked = false;
            }
        }
        
        async loadHandDetectionModel() {
            const statusEl = document.getElementById('camera-status');
            
            if (typeof Hands === 'undefined') {
                statusEl.textContent = 'Camera Status: MediaPipe not available. Using manual control.';
                statusEl.classList.remove('text-yellow-400', 'text-green-400');
                statusEl.classList.add('text-red-400');
                State.gestureMode = false;
                return;
            }

            try {
                statusEl.textContent = 'Camera Status: Loading hand detection model...';
                
                this.hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                this.hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                this.hands.onResults((results) => {
                    this.processHandResults(results);
                });
                
                this.camera = new Camera(this.webcam, {
                    onFrame: async () => {
                        if (State.gestureMode && this.hands) {
                            await this.hands.send({ image: this.webcam });
                        }
                    },
                    width: 1280,
                    height: 720
                });
                
                await this.camera.start();
                
                this.isModelLoaded = true;
                statusEl.textContent = 'Camera Status: Hand tracking ACTIVE âœ“';
                statusEl.classList.remove('text-yellow-400', 'text-red-400');
                statusEl.classList.add('text-green-400');
                
            } catch (error) {
                console.error("Error loading hand detection model:", error);
                statusEl.textContent = 'Camera Status: Model load FAILED. Using manual control.';
                statusEl.classList.remove('text-yellow-400', 'text-green-400');
                statusEl.classList.add('text-red-400');
                this.isModelLoaded = false;
                State.gestureMode = false;
            }
        }
        
        processHandResults(results) {
            if (!State.gestureMode) return;
            
            const statusEl = document.getElementById('camera-status');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                const wrist = landmarks[0];
                const wristZ = wrist.z || 0;
                State.targetScale = THREE.MathUtils.clamp((wristZ + 0.3) * 2.0, 0.1, 1.0);
                
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                
                const dx = thumbTip.x - indexTip.x;
                const dy = thumbTip.y - indexTip.y;
                const dz = (thumbTip.z || 0) - (indexTip.z || 0);
                
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                State.targetSpread = THREE.MathUtils.clamp(distance * 5.0, 0.0, 1.0);
                
                this.detectSnap(State.targetSpread);
                this.updateDebugDisplay();
                
                if (statusEl.classList.contains('text-green-400')) {
                    statusEl.textContent = 'Hand Tracking: ACTIVE âœ“';
                }
                
            } else {
                State.targetScale = 0.5;
                State.targetSpread = 0.5;
                
                if (statusEl.classList.contains('text-green-400')) {
                    statusEl.textContent = 'Hand Tracking: No hand detected';
                }
            }
        }
        
        onPointerDown(event) {
            if (State.gestureMode) return;
            this.isDragging = true;
            this.lastMouseY = this.getPointerY(event);
        }

        onPointerUp(event) {
            if (State.gestureMode) return;
            this.isDragging = false;
        }

        getPointerX(event) {
            let clientX = event.touches ? event.touches[0].clientX : event.clientX;
            return Math.min(1.0, Math.max(0.0, clientX / window.innerWidth));
        }

        getPointerY(event) {
            let clientY = event.touches ? event.touches[0].clientY : event.clientY;
            return Math.min(1.0, Math.max(0.0, 1.0 - (clientY / window.innerHeight)));
        }

        onPointerMove(event) {
            if (State.gestureMode) return;
            if (this.isDragging) {
                State.targetScale = this.getPointerX(event); 
                State.targetSpread = this.getPointerY(event); 
                this.detectSnap(State.targetSpread);
                this.updateDebugDisplay();
            }
        }

        updateCameraInput() {
            if (!State.gestureMode) return;
            
            if (!this.isModelLoaded) {
                const t = performance.now() * 0.0005;
                State.targetScale = (Math.sin(t) * 0.2 + 0.6); 
                State.targetSpread = (Math.cos(t * 0.6) * 0.4 + 0.5);
            }
        }
        
        detectSnap(currentSpread) {
            if (State.fireworksCooldown > 0) return;
            const spreadDelta = this.lastGestureSpread - currentSpread;
            
            if (currentTemplate.name === Templates.FIREWORKS.name && spreadDelta > 0.35) {
                this.triggerFireworksBurst();
                State.fireworksCooldown = 60;
            }
            
            this.lastGestureSpread = currentSpread;
        }

        triggerFireworksBurst() {
            State.targetSpread = 1.0; 
            State.targetScale = 0.5;
            
            try {
                const synth = new Tone.NoiseSynth({
                    noise: { type: 'white' },
                    envelope: { attack: 0.001, decay: 0.5, sustain: 0, release: 0.5 }
                }).toDestination();
                synth.triggerAttackRelease(0.5);
            } catch (e) {
                console.warn("Tone.js failed to initialize or play sound:", e);
            }
        }
        
        updateDebugDisplay() {
            const debugEl = document.getElementById('gesture-debug');
            if (debugEl) {
                debugEl.textContent = 
                    `Scale: ${State.targetScale.toFixed(2)} | Spread: ${State.targetSpread.toFixed(2)}`;
                debugEl.classList.remove('hidden');
            }
        }
    }
    const gestureController = new GestureController();

    const vertexShader = `
        uniform float time;
        uniform float globalScale;
        uniform float spreadFactor;
        uniform float noiseStrength;
        attribute vec3 initialPosition;
        attribute float initialSize;
        attribute float initialDelay;
        attribute vec3 templatePos;

        varying float vAlpha;
        
        float hash(float n) {
            return fract(sin(n) * 43758.5453);
        }

        float noise(vec3 x) {
            const vec3 step = vec3(110, 241, 171);
            vec3 i = floor(x);
            vec3 f = fract(x);
            f = f*f*(3.0-2.0*f);

            float n = i.x * step.x + i.y * step.y + i.z * step.z; 
            float res = mix(mix(mix( hash(n + 0.0), hash(n + step.z), f.z),
                                mix( hash(n + step.y), hash(n + step.y + step.z), f.z), f.z),
                            mix(mix( hash(n + step.x), hash(n + step.x + step.z), f.z),
                                mix( hash(n + step.x + step.y), hash(n + step.x + step.y + step.z), f.z), f.z), f.x);
            return res;
        }

        void main() {
            float t = time * 0.5 - initialDelay;
            float life = max(0.0, t);
            
            vec3 pos = templatePos * spreadFactor;
            
            vec3 noiseOffset = vec3(
                noise(pos * 0.5 + t * 0.1),
                noise(pos * 0.5 + t * 0.1 + 10.0),
                noise(pos * 0.5 + t * 0.1 + 20.0)
            ) * 2.0 - 1.0;
            
            pos += noiseOffset * noiseStrength * globalScale;

            vec4 modelViewPosition = modelViewMatrix * vec4(pos * globalScale, 1.0);
            gl_Position = projectionMatrix * modelViewPosition;

            gl_PointSize = initialSize * (1.0 + (noise(initialPosition.xyz) * 0.5)) * (200.0 / -modelViewPosition.z);
            gl_PointSize = max(gl_PointSize, 1.0);
            
            vAlpha = 1.0;
        }
    `;

    const fragmentShader = `
        uniform vec3 uParticleColor;
        varying float vAlpha;

        void main() {
            float r = 0.0;
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            r = dot(cxy, cxy);
            
            if (r > 1.0) {
                discard;
            }
            
            float alpha = vAlpha * smoothstep(1.0, 0.5, r);

            gl_FragColor = vec4(uParticleColor, alpha);
        }
    `;

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10;
        
        const container = document.getElementById('canvas-container');
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        
        setupParticles(State.particleCount, currentTemplate);
        setupUI();
        
        Tone.start().then(() => {
            console.log("Tone.js audio context started.");
        }).catch(err => {
            console.error("Failed to start Tone.js audio context:", err);
        });

        gestureController.init();

        window.addEventListener('resize', onWindowResize);
    }

    function setupParticles(count, template) {
        if (particles) {
            scene.remove(particles);
            geometry.dispose();
            material.dispose();
        }

        State.particleCount = count;
        geometry = new THREE.BufferGeometry();

        const positions = new Float32Array(count * 3);
        const templatePositions = new Float32Array(count * 3);
        const initialSizes = new Float32Array(count);
        const initialDelays = new Float32Array(count);

        for (let i = 0; i < count; i++) {
            positions[i * 3 + 0] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 10;

            const templateVec = template.spawnFn(i, count);
            templatePositions[i * 3 + 0] = templateVec.x;
            templatePositions[i * 3 + 1] = templateVec.y;
            templatePositions[i * 3 + 2] = templateVec.z;

            initialSizes[i] = State.baseSize * (1.0 + Math.random() * 0.5);
            initialDelays[i] = Math.random() * 5.0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('initialPosition', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('templatePos', new THREE.BufferAttribute(templatePositions, 3));
        geometry.setAttribute('initialSize', new THREE.BufferAttribute(initialSizes, 1));
        geometry.setAttribute('initialDelay', new THREE.BufferAttribute(initialDelays, 1));

        const hslColor = new THREE.Color().setHSL(State.hue / 360, 1.0, 0.7);

        uniforms = {
            time: { value: 0.0 },
            globalScale: { value: State.globalScale },
            spreadFactor: { value: State.spreadFactor },
            noiseStrength: { value: State.noiseStrength },
            uParticleColor: { value: hslColor },
        };

        material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            depthTest: false,
            blending: THREE.AdditiveBlending,
        });
        
        particles = new THREE.Points(geometry, material);
        scene.add(particles);
        
        updateTemplateIcons(template.name);
    }

    function animate(currentTime) {
        animationId = requestAnimationFrame(animate);

        const delta = (currentTime - State.lastUpdateTime) / 1000;
        State.lastUpdateTime = currentTime;
        
        updateFPS(currentTime);

        if (State.gestureMode) {
            gestureController.updateCameraInput();
        } 

        if (State.fireworksCooldown > 0) {
            State.fireworksCooldown--;
            if (State.fireworksCooldown === 0 && currentTemplate.name === Templates.FIREWORKS.name) {
                State.targetSpread = 0.1;
                State.targetScale = 0.3;
            }
        }

        State.globalScale = THREE.MathUtils.lerp(State.globalScale, State.targetScale * 5.0 + 1.0, LERP_FACTOR);
        State.spreadFactor = THREE.MathUtils.lerp(State.spreadFactor, State.targetSpread * 8.0 + 1.0, LERP_FACTOR);
        
        uniforms.time.value += delta;
        uniforms.globalScale.value = State.globalScale;
        uniforms.spreadFactor.value = State.spreadFactor;
        uniforms.noiseStrength.value = State.noiseStrength;

        camera.rotation.y = Math.sin(uniforms.time.value * 0.05) * 0.1;
        camera.rotation.x = Math.cos(uniforms.time.value * 0.03) * 0.05;
        camera.position.x = Math.sin(uniforms.time.value * 0.1) * 0.5;
        
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function setupUI() {
        const selectorEl = document.getElementById('template-selector');
        Object.keys(Templates).forEach(key => {
            const template = Templates[key];
            const iconEl = document.createElement('div');
            iconEl.className = 'template-icon text-3xl flex-shrink-0';
            iconEl.innerHTML = template.icon;
            iconEl.title = template.name;
            iconEl.id = `icon-${key}`;
            
            iconEl.addEventListener('click', () => {
                currentTemplate = template;
                setupParticles(State.particleCount, currentTemplate);
            });
            selectorEl.appendChild(iconEl);
        });
        updateTemplateIcons(currentTemplate.name);

        const hueSlider = document.getElementById('hue-slider');
        const colorPreview = document.getElementById('color-preview');
        hueSlider.addEventListener('input', (e) => {
            State.hue = parseInt(e.target.value);
            const color = `hsl(${State.hue}, 100%, 70%)`;
            colorPreview.style.backgroundColor = color;
            document.documentElement.style.setProperty('--particle-color', color);
            uniforms.uParticleColor.value.setHSL(State.hue / 360, 1.0, 0.7);
        });

        const countSlider = document.getElementById('particle-count-slider');
        const countValue = document.getElementById('count-value');
        countSlider.addEventListener('change', (e) => {
            const newCount = parseInt(e.target.value);
            setupParticles(newCount, currentTemplate);
            countValue.textContent = newCount;
        });
        countSlider.addEventListener('input', (e) => {
            countValue.textContent = parseInt(e.target.value);
        });

        const sizeSlider = document.getElementById('particle-size-slider');
        const sizeValue = document.getElementById('size-value');
        sizeSlider.addEventListener('input', (e) => {
            State.baseSize = parseFloat(e.target.value);
            sizeValue.textContent = State.baseSize.toFixed(1);
            setupParticles(State.particleCount, currentTemplate); 
        });

        const noiseSlider = document.getElementById('motion-noise-slider');
        const noiseValue = document.getElementById('noise-value');
        noiseSlider.addEventListener('input', (e) => {
            State.noiseStrength = parseFloat(e.target.value);
            noiseValue.textContent = State.noiseStrength.toFixed(1);
            uniforms.noiseStrength.value = State.noiseStrength;
        });
        
        const toggleEl = document.getElementById('toggle-gesture-control');
        const hintEl = document.getElementById('control-hint');
        const cameraStatusEl = document.getElementById('camera-status');
        toggleEl.addEventListener('change', (e) => {
            State.gestureMode = e.target.checked;
            if (State.gestureMode) {
                hintEl.textContent = 'Gesture Mode ON. Track your hand in front of the camera.';
                cameraStatusEl.classList.remove('hidden');
                
                if (!gestureController.isModelLoaded) {
                    gestureController.setupCameraStream();
                } else if (gestureController.camera) {
                    gestureController.camera.start();
                }
            } else {
                hintEl.textContent = 'Manual Mode ON. Drag mouse/touch to control scale (X) and spread (Y).';
                cameraStatusEl.classList.add('hidden');
                document.getElementById('gesture-debug').classList.add('hidden');
                
                if (gestureController.camera) {
                    gestureController.camera.stop();
                }
            }
        });
    }

    function updateTemplateIcons(activeName) {
        document.querySelectorAll('.template-icon').forEach(icon => {
            icon.classList.remove('active');
            if (icon.title === activeName) {
                icon.classList.add('active');
            }
        });
    }

    let frameCount = 0;
    let lastFPSUpdate = performance.now();
    const fpsEl = document.getElementById('fps-display');
    const perfTipEl = document.getElementById('perf-tip');

    function updateFPS(currentTime) {
        frameCount++;
        if (currentTime > lastFPSUpdate + 1000) {
            const fps = Math.round(frameCount * 1000 / (currentTime - lastFPSUpdate));
            fpsEl.textContent = `FPS: ${fps}`;
            
            if (fps < 30 && State.particleCount > MIN_PARTICLES) {
                const newCount = Math.max(MIN_PARTICLES, State.particleCount - 10000);
                setupParticles(newCount, currentTemplate);
                document.getElementById('particle-count-slider').value = newCount;
                document.getElementById('count-value').textContent = newCount;
                perfTipEl.classList.remove('hidden');
            } else {
                 perfTipEl.classList.add('hidden');
            }

            frameCount = 0;
            lastFPSUpdate = currentTime;
        }
    }

    window.onload = function() {
        init();
        animate(performance.now());
        
        document.getElementById('toggle-gesture-control').dispatchEvent(new Event('change'));
    };

</script>
</body>
</html>